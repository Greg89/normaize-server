name: Version Bump

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    branches: [main]
    types: [completed]

jobs:
  version-bump:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    permissions:
      contents: write
      actions: read
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        ref: main

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Ensure we're on main branch
      run: |
        # Make sure we're on the main branch
        git checkout main
        git pull origin main

    - name: Get current version
      id: current-version
      run: |
        echo "=== Current Version Detection Debug ==="
        
        # Extract current version from .csproj files
        echo "Looking for Version tags in .csproj files..."
        find . -name "*.csproj" -exec echo "Found: {}" \;
        
        echo "Extracting version from Normaize.API.csproj..."
        VERSION=$(grep -o '<Version>.*</Version>' Normaize.API/Normaize.API.csproj | sed 's/<Version>\(.*\)<\/Version>/\1/' || echo "1.0.0")
        
        echo "Raw grep output:"
        grep -o '<Version>.*</Version>' Normaize.API/Normaize.API.csproj || echo "No Version tag found"
        
        echo "Extracted version: '$VERSION'"
        
        # If no version found, default to 1.0.0
        if [ -z "$VERSION" ] || [ "$VERSION" = "" ]; then
          VERSION="1.0.0"
          echo "Version was empty, defaulting to: $VERSION"
        fi
        
        echo "Final current version: $VERSION"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "=== End Current Version Detection Debug ==="

    - name: Determine version bump type
      id: bump-type
      run: |
        # Analyze commit messages since last version bump
        # Look for keywords to determine bump type
        COMMIT_MESSAGES=$(git log --oneline --since="1 day ago" | head -10)
        echo "Recent commits:"
        echo "$COMMIT_MESSAGES"
        
        if echo "$COMMIT_MESSAGES" | grep -qi "breaking\|major\|!:"; then
          echo "bump-type=major" >> $GITHUB_OUTPUT
          echo "Major version bump detected"
        elif echo "$COMMIT_MESSAGES" | grep -qi "feat\|feature\|new"; then
          echo "bump-type=minor" >> $GITHUB_OUTPUT
          echo "Minor version bump detected"
        else
          echo "bump-type=patch" >> $GITHUB_OUTPUT
          echo "Patch version bump detected"
        fi

    - name: Calculate new version
      id: new-version
      run: |
        CURRENT_VERSION="${{ steps.current-version.outputs.version }}"
        BUMP_TYPE="${{ steps.bump-type.outputs.bump-type }}"
        
        echo "=== Version Calculation Debug ==="
        echo "Current version from step: $CURRENT_VERSION"
        echo "Bump type from step: $BUMP_TYPE"
        
        # Parse current version with fallback
        if [[ "$CURRENT_VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
          MAJOR="${BASH_REMATCH[1]}"
          MINOR="${BASH_REMATCH[2]}"
          PATCH="${BASH_REMATCH[3]}"
          echo "Successfully parsed version: $MAJOR.$MINOR.$PATCH"
        else
          echo "Invalid version format, defaulting to 1.0.0"
          MAJOR=1
          MINOR=0
          PATCH=0
        fi
        
        echo "Parsed version components: MAJOR=$MAJOR, MINOR=$MINOR, PATCH=$PATCH"
        
        # Calculate new version based on bump type
        case $BUMP_TYPE in
          "major")
            NEW_MAJOR=$((MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
            echo "Major bump: $MAJOR.$MINOR.$PATCH -> $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            ;;
          "minor")
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$((MINOR + 1))
            NEW_PATCH=0
            echo "Minor bump: $MAJOR.$MINOR.$PATCH -> $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            ;;
          "patch")
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$MINOR
            NEW_PATCH=$((PATCH + 1))
            echo "Patch bump: $MAJOR.$MINOR.$PATCH -> $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            ;;
          *)
            echo "Unknown bump type, defaulting to patch"
            NEW_MAJOR=$MAJOR
            NEW_MINOR=$MINOR
            NEW_PATCH=$((PATCH + 1))
            echo "Default patch bump: $MAJOR.$MINOR.$PATCH -> $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
            ;;
        esac
        
        NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
        echo "Final new version: $NEW_VERSION"
        echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "=== End Version Calculation Debug ==="

    - name: Update version in project files
      shell: pwsh
      run: |
        $NEW_VERSION = "${{ steps.new-version.outputs.new-version }}"
        Write-Host "Updating version to: $NEW_VERSION"
        
        # Find all .csproj files and update their version
        $csprojFiles = Get-ChildItem -Path . -Filter "*.csproj" -Recurse
        Write-Host "Found $($csprojFiles.Count) .csproj files"
        
        foreach ($file in $csprojFiles) {
          Write-Host "Processing: $($file.FullName)"
          
          # Read the file content
          $content = Get-Content $file.FullName -Raw
          
          # Update the version using regex
          $updatedContent = $content -replace '<Version>.*?</Version>', "<Version>$NEW_VERSION</Version>"
          
          # Write back to file
          Set-Content $file.FullName -Value $updatedContent -NoNewline
          
          Write-Host "Updated version in: $($file.Name)"
        }
        
        # Also update AssemblyInfo.cs if it exists
        $assemblyInfoFiles = Get-ChildItem -Path . -Filter "AssemblyInfo.cs" -Recurse
        foreach ($file in $assemblyInfoFiles) {
          Write-Host "Processing AssemblyInfo: $($file.FullName)"
          
          $content = Get-Content $file.FullName -Raw
          $updatedContent = $content -replace 'AssemblyVersion\(".*?"\)', "AssemblyVersion(`"$NEW_VERSION`")"
          
          Set-Content $file.FullName -Value $updatedContent -NoNewline
          Write-Host "Updated AssemblyVersion in: $($file.Name)"
        }
        
        Write-Host "Version update completed for $NEW_VERSION"

    - name: Check for changes
      id: check-changes
      run: |
        echo "Checking for changes after version update..."
        
        # Show current git status
        echo "Git status:"
        git status --porcelain
        
        # Show what files would be staged
        echo "Files that would be staged:"
        git add -A --dry-run
        
        # Actually stage the files
        git add -A
        
        # Show staged changes
        echo "Staged changes:"
        git diff --staged --name-only
        
        # Check if there are any staged changes
        if git diff --staged --quiet; then
          echo "No changes to commit"
          echo "has-changes=false" >> $GITHUB_OUTPUT
          
          # Show the current version in files for debugging
          echo "Current versions in .csproj files:"
          grep -r "<Version>" . --include="*.csproj" || echo "No Version tags found"
        else
          echo "Changes detected"
          echo "has-changes=true" >> $GITHUB_OUTPUT
          
          # Show what changed
          echo "Changes that will be committed:"
          git diff --staged
        fi

    - name: Create version bump branch and commit
      if: steps.check-changes.outputs.has-changes == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Create a new branch for the version bump
        BRANCH_NAME="version-bump/${{ steps.new-version.outputs.new-version }}"
        git checkout -b "$BRANCH_NAME"
        
        # Commit the version changes with [skip ci] to prevent CI loops
        git commit -m "chore: bump version to ${{ steps.new-version.outputs.new-version }} [skip ci]"
        
        # Push the branch to origin
        git push origin "$BRANCH_NAME"
        
        echo "branch-name=$BRANCH_NAME" >> $GITHUB_OUTPUT

    - name: Skip commit - no changes
      if: steps.check-changes.outputs.has-changes == 'false'
      run: |
        echo "No version changes detected, skipping commit"
        echo "This might happen if the version was already bumped or no relevant changes were made"

    - name: Create Pull Request
      if: steps.check-changes.outputs.has-changes == 'true'
      uses: peter-evans/create-pull-request@v6
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: "chore: bump version to ${{ steps.new-version.outputs.new-version }} [skip ci]"
        branch: ${{ steps.check-changes.outputs.has-changes == 'true' && format('version-bump/{0}', steps.new-version.outputs.new-version) || '' }}
        base: main
        title: "chore: bump version to ${{ steps.new-version.outputs.new-version }}"
        body: |
          ## Automated Version Bump
          
          This PR was automatically created after a successful CI/CD pipeline completion.
          
          ### Changes
          - Updated version from `${{ steps.current-version.outputs.version }}` to `${{ steps.new-version.outputs.new-version }}`
          - Version bump type: **${{ steps.bump-type.outputs.bump-type }}**
          
          ### Version Bump Details
          - **Previous Version**: ${{ steps.current-version.outputs.version }}
          - **New Version**: ${{ steps.new-version.outputs.new-version }}
          - **Bump Type**: ${{ steps.bump-type.outputs.bump-type }}
          
          ### Files Changed
          - All `.csproj` files updated with new version
          - AssemblyInfo.cs updated (if present)
          
          ### Notes
          - This PR includes `[skip ci]` in the commit message to prevent CI loops
          - Merge this PR to complete the version bump
          - A GitHub release will be created after the PR is merged
        labels: |
          automated
          version-bump
        assignees: ${{ github.actor }}
        reviewers: ${{ github.actor }}

    - name: Check if tag already exists
      id: check-tag
      run: |
        TAG_NAME="v${{ steps.new-version.outputs.new-version }}"
        echo "Checking if tag $TAG_NAME already exists..."
        
        if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
          echo "Tag $TAG_NAME already exists"
          echo "tag-exists=true" >> $GITHUB_OUTPUT
        else
          echo "Tag $TAG_NAME does not exist"
          echo "tag-exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Create GitHub Release (after PR merge)
      if: steps.check-changes.outputs.has-changes == 'true' && steps.check-tag.outputs.tag-exists == 'false'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.new-version.outputs.new-version }}
        release_name: Release v${{ steps.new-version.outputs.new-version }}
        body: |
          ## Version ${{ steps.new-version.outputs.new-version }}
          
          This is an automated release created after successful CI/CD pipeline completion and version bump PR merge.
          
          ### Changes
          - Automated version bump
          - All tests passed
          - CI/CD pipeline successful
          - Version bump PR merged
          
          ### Version Bump Type
          **${{ steps.bump-type.outputs.bump-type }}** version increment
          
          Previous version: ${{ steps.current-version.outputs.version }}
          New version: ${{ steps.new-version.outputs.new-version }}
        draft: false
        prerelease: false

    - name: Skip release - tag already exists
      if: steps.check-changes.outputs.has-changes == 'true' && steps.check-tag.outputs.tag-exists == 'true'
      run: |
        echo "Tag v${{ steps.new-version.outputs.new-version }} already exists, skipping release creation"
        echo "This might happen if the version bump workflow ran multiple times or the release was created manually" 